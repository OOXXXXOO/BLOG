<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!--Description-->
    
        <meta name="description" content="Research about HCI/CG/VR/AR">
    

    <!--Author-->
    
        <meta name="author" content="Tom winshare">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="unity &amp; Computer graphics Chapter(2)"/>
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Winshare"/>

    <!--Page Cover-->
    
        <meta property="og:image" content="undefined"/>
    

    <!-- Title -->
    
    <title>unity &amp; Computer graphics Chapter(2) - Winshare</title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/sass/main.css">

    <!--[if lt IE 8]>
        <script src="/js/ie/html5shiv.js"></script>
    <![endif]-->

    <!--[if lt IE 8]>
        <link rel="stylesheet" href="/sass/ie8.css">
    <![endif]-->

    <!--[if lt IE 9]>
        <link rel="stylesheet" href="/sass/ie9.css">
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-98667296-1', 'auto');
        ga('send', 'pageview');

    </script>



</head>

<body>

    <div id="wrapper">

        <!-- Menu -->
        <!-- Header -->
<header id="header">
    <div class="inner">

        <!-- Logo -->
        <a href="/" class="logo">
            <span class="symbol"><img src="/images/logo.svg" alt="" /></span><span class="title">Winshare</span>
        </a>

        <!-- Nav -->
        <nav>
            <ul>
                <li><a href="#menu">Menu</a></li>
            </ul>
        </nav>

    </div>
</header>

<!-- Menu -->
<nav id="menu">
    <h2>Menu</h2>
    <ul>
        
            <li>
                <a href="/">Home</a>
            </li>
        
            <li>
                <a href="/archives">Archives</a>
            </li>
        
            <li>
                <a href="/about.html">About</a>
            </li>
        
    </ul>
</nav>


        <div id="main">
            <div class="inner">

                <!-- Main Content -->
                

    <h1>unity & Computer graphics Chapter(2)</h1>


    <span class="image main"><img src="http://img2.91.com/uploads/allimg/130418/32-13041Q50312.jpg" alt="" /></span>


<!-- Gallery -->


<!-- Content -->
<hr>
<blockquote>
<p>提示：本篇将会非常长~</p>
<h1 id="本系列文章分为"><a href="#本系列文章分为" class="headerlink" title="本系列文章分为"></a>本系列文章分为</h1></blockquote>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a><a href="http://blog.csdn.net/admintan/article/details/53861781" target="_blank" rel="external"><strong>硬件</strong></a></h2><h2 id="编程入门"><a href="#编程入门" class="headerlink" title="编程入门"></a><strong>编程入门</strong></h2><h2 id="工程实践"><a href="#工程实践" class="headerlink" title="工程实践"></a><strong>工程实践</strong></h2><hr>
<h1 id="上一篇"><a href="#上一篇" class="headerlink" title="上一篇"></a>上一篇</h1><p>主要介绍了GPU的特征工作原理  以及渲染的底层流程  其实对于<strong>新架构</strong>而言还有所不同<br>Shader描述了<strong>如何渲染物体</strong>的信息，包括：</p>
<hr>
<p><strong>Texture Setup、纹理设置</strong><br><strong>Material Property、材质设置</strong><br><strong>Render State、渲染状态</strong><br><strong>Blend Setup、混合设置</strong><br><strong>Pixel Shader、像素着色</strong><br><strong>Vertex Shader、定点着色</strong><br><strong>Render Target Setup 渲染目标设置</strong></p>
<hr>
<p>Shader并不直接和几何体相关联，因为对于同一个几何体，有可能会用不同的Shader来渲染。<br>为了简化描述我们来定义一下：<br><strong>vs: vertex shader, 顶点处理/多边形处理的</strong><br><strong>ps: pixel shader,  处理像素单位的阴影和处理相关纹理</strong><br>以上两种shader都是可编程的<br>在各自的着色器单元(Shader Unit)上，有着把各种各样的Shader程序来实现为3D图形的处理的结构。而且，作为用语，如果直接说[Programmable Shader]，有指双方（VS和PS）的情况，或者是指这个整体的概念。<br>并且，由于这个Shader程序是软件，开发者可以自己制作独创的Shader程序，就可以在GPU上实现新的图形功能。<br>但是在之前的着色器架构中无法面对任务的调节  造成闲置资源<br><img src="http://img.blog.csdn.net/20161228202950468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW50YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>而在现有的统一着色器架构下  资源配置得到了有效保障<br><img src="http://img.blog.csdn.net/20161228203100865?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW50YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<p>所以在DX11之后通用shader架构得到了广泛使用  比较理想的过程是：<br><img src="http://img.blog.csdn.net/20161228203926795?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW50YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<p>#当然<br> <strong>以上看不懂也无所谓  因为这个是软件之前的一点小铺垫。</strong></p>
<h1 id="正式篇前导一，纹理？材质？贴图？"><a href="#正式篇前导一，纹理？材质？贴图？" class="headerlink" title="正式篇前导一，纹理？材质？贴图？"></a><strong>正式篇前导一，纹理？材质？贴图？</strong></h1><p>整个 CG 领域中这三个概念都是差不多的，在一般的实践中，大致上的层级关系是：</p>
<h3 id="材质-Material包含贴图-Map，贴图包含纹理-Texture。"><a href="#材质-Material包含贴图-Map，贴图包含纹理-Texture。" class="headerlink" title="材质 Material包含贴图 Map，贴图包含纹理 Texture。"></a><strong><em>材质 Material包含贴图 Map，贴图包含纹理 Texture。</em></strong></h3><hr>
<p>而我们要说的时更广泛应用的概念</p>
<h3 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a><strong>纹理</strong></h3><p>是最基本的数据输入单位，游戏领域基本上都用的是位图。常见格式有PNG，TGA，BMP，TIFF此外还有程序化生成的纹理 Procedural Texture。<br>在内存中通常表示为二维像素数组。</p>
<h3 id="贴图"><a href="#贴图" class="headerlink" title="贴图"></a><strong>贴图</strong></h3><p>英语 Map 其实包含了另一层含义就是“映射”。其功能就是把纹理通过 UV 坐标映射到3D 物体表面。贴图包含了除了纹理以外其他很多信息，比方说 UV 坐标、贴图输入输出控制等等。<br>一张图便能说明其之间的关系<br><img src="http://img.blog.csdn.net/20170126131407607?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW50YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="材质"><a href="#材质" class="headerlink" title="材质"></a><strong>材质</strong></h3><p>本质就是一个数据集，主要功能就是给渲染器提供数据和光照算法。贴图就是其中数据的一部分，根据用途不同，贴图也会被分成不同的类型，比方说 Diffuse Map，Specular Map，Normal Map 和 Gloss Map 等等。另外一个重要部分就是光照模型 Shader ，用以实现不同的渲染效果。<br><strong>贴图</strong>种类繁多：我做个不完全总结</p>
<p>####　<strong>Diffuse Map -</strong><br>漫反射贴图/也被称作反照率贴图albedo map  存储了物体相应部分漫反射颜色</p>
<h4 id="Normal-Map"><a href="#Normal-Map" class="headerlink" title="　Normal Map -"></a>　<strong>Normal Map -</strong></h4><p>法线贴图 本质上存储的是被RGB值编码的法向量   表现凹凸，比如一些凹凸不平的表面，光影在表面产生实时变化 常用来低多边形表现高多边形细节  比如在高多边形下生成normal map在匹配给低多边形模型  是一种常见的降低性能要求的做法</p>
<p><img src="http://img.blog.csdn.net/20161231153456703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW50YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>对于讲解normal map来说<a href="http://blog.csdn.net/cywater2000/article/details/749341#comments" target="_blank" rel="external">这篇文章</a>很值得借鉴<br><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/cywater2000/102371/o_n2.jpg" alt="这里写图片描述"><br>N’= N + D =[0,0,c]+ D =[a,b,c]<br>a = -dF/du <em> 1/k<br>b = -dF/dv  </em> 1/k<br>c = 1</p>
<p>常规来说就是<strong>光向量和法向量的点积</strong>来确定明暗以表现凹凸质感，也就是<strong>把法线存在纹理中</strong></p>
<p>我们又会发现另外一个奇怪的地方</p>
<h4 id="法线贴图的颜色为什么都这么怪？"><a href="#法线贴图的颜色为什么都这么怪？" class="headerlink" title="法线贴图的颜色为什么都这么怪？"></a><strong>法线贴图的颜色为什么都这么怪？</strong></h4><p>事实上，真正的法线贴图并不是记录贴图上每个点的法线的绝对角度，而是记录的是相对于平面的一个差值。这样的话，随着平面的3D变换都能够实现即时的法线运算了。而借RGB数据存储的法线信息会被法线方向扰动，于是在RGB（x，y，z）上的平均分布空间上 x，z 值较大或者y得值比较大 因此表现出来合成的结果上普遍是紫色（xz）代表面  而绿色（y）反应深浅</p>
<p>####　<strong>Specular Map -</strong><br> 高光贴图  表现质感 高光区域大小可真实反映材质区别</p>
<p>####　<strong>Gloss Map -</strong><br>光泽贴图，每个纹理元素上描述光泽程度</p>
<p>而讲解贴图和纹理的工作机理中<a href="http://blog.digitaltutors.com/understanding-difference-texture-maps/" target="_blank" rel="external">这篇博客</a>讲的很不错</p>
<p>####<strong>总体上说  他们都是要被shader加工的原材料</strong></p>
<h1 id="正式篇前导二，光照模型？"><a href="#正式篇前导二，光照模型？" class="headerlink" title="正式篇前导二，光照模型？  "></a><strong>正式篇前导二，光照模型？  </strong></h1><p>我们先来探讨一下几个问题</p>
<h3 id="1-当一个物体能被我们看见需要具备什么因素"><a href="#1-当一个物体能被我们看见需要具备什么因素" class="headerlink" title="1.  当一个物体能被我们看见需要具备什么因素 ?"></a>1.  <strong>当一个物体能被我们看见需要具备什么因素 ?</strong></h3><h3 id="2-当一个物体是不同材质的时候，视觉上的区别在哪里？"><a href="#2-当一个物体是不同材质的时候，视觉上的区别在哪里？" class="headerlink" title="2.  当一个物体是不同材质的时候，视觉上的区别在哪里？"></a>2.  <strong>当一个物体是不同材质的时候，视觉上的区别在哪里？</strong></h3><p>带着这两个问题  我们来说一下  什么是光照模型<br>它总结了在什么情况下　一个物体能够被看见　以及以一个近似的概念描述了真实情况下光照的种类</p>
<h2 id="基础－Phone式光照模型（Phone-reflection-model）"><a href="#基础－Phone式光照模型（Phone-reflection-model）" class="headerlink" title="基础－Phone式光照模型（Phone reflection model）"></a>基础－<strong>Phone</strong>式光照模型（<em>Phone reflection model</em>）</h2><p>####　<strong>真实世界中的光照效果抽象为三种独立的光照效果的叠加</strong></p>
<p>####<strong>1．环境光(Ambient)</strong><br>此为<strong>模拟环境中的整体光照水平</strong>，是间接反射光的粗略估计，间接反射的光使阴影部分不会变成全黑 关于环境光还有个事实，1某个可以独立分析的局部场合的环境光强和能够进入这个地方的光的强度有关。<br>其计算公式为：<img src="http://images2015.cnblogs.com/blog/746883/201603/746883-20160320162138068-1503500230.png" alt="这里写图片描述"></p>
<p>####<strong>2．漫反射光(Diffuse)</strong><br>模拟直接光源在表面均匀的向各个方向反射，能够逼近真实光源照射到哑光表面的反射。比如在阳光下，由于路面粗糙的性质，我们发现从任意一个角度观察路面，亮度都是差不多。<br>其计算公式为<img src="http://images2015.cnblogs.com/blog/746883/201603/746883-20160320162152271-2111024530.png" alt="这里写图片描述"></p>
<p>####<strong>3．镜面反射光(Specular)</strong><br>模拟在光滑表面会看到的光亮高光。会出现在光源的直接反射方向。镜子、金属等表面光亮的物体会有镜面反射光。镜面反射光同时与物体表面朝向、光线方向、视点位置有关。如图<br><img src="http://images2015.cnblogs.com/blog/746883/201603/746883-20160320162204553-1222989560.png" alt="这里写图片描述"><br><strong>I是入射光，N是表面法线，R是反射光线，V是从物体上的目标观察点指向视点的向量，a是V和R的夹角。</strong></p>
<p>我们可以判断出一个规律，夹角a越小，即视线与反射方向的偏离越小，则目标点的光强越大<br>其计算公式为：<img src="http://images2015.cnblogs.com/blog/746883/201603/746883-20160320162212881-968793316.png" alt="这里写图片描述"></p>
<p><strong>Ks为物体对于反射光线的衰减系数</strong><br><strong>Shininess为高光指数</strong></p>
<p><strong>高光指数</strong>反映了物体表面的光泽程度。<br><strong>Shininess越大，反射光越集中</strong>，当偏离反射方向时，光线衰减的越厉害，只有当视线方向与反射光线方向非常接近时才能看到镜面反射的高光现象，此时，镜面反射光将会在反射方向附近形成亮且小的光斑；<br><strong>Shininess 越小，表示物体越粗糙，</strong>反射光分散，观察到的光斑区域小，强度弱。</p>
<blockquote>
<p>以上所在的公式都是便于理解的形式  实际要复杂得多</p>
</blockquote>
<p>###　<strong>最后可得：<img src="http://images2015.cnblogs.com/blog/746883/201603/746883-20160320162230318-945939529.png" alt="这里写图片描述"></strong></p>
<p>其组成类似于<br><img src="http://image.lxway.com/upload/5/f2/5f2d81ad4bef2bb556ec63bb764da68f_thumb.png" alt="这里写图片描述"></p>
<p>至于更多的光照模型结合了更多的物理光学等信息　在模拟单种材质例如塑料　合金　石膏陶瓷等等上要好于Phone式模型的效果  但是基本上属于Phone式模型的扩充</p>
<hr>
<blockquote>
<p>有了以上基础概念  我们就可以更好的理解shader的编写了</p>
<h1 id="正式篇第一节-扫盲"><a href="#正式篇第一节-扫盲" class="headerlink" title="正式篇第一节 扫盲"></a><strong>正式篇第一节 扫盲</strong></h1><p>前一章提到了  可编程shader分为<strong>vertex （顶点）/fragement（片段） shader</strong><br>其可由多种语言去编写  比如CGSL/HLSL/CG<br>我们先来比较一下  三种主流语言的优缺点</p>
<h3 id="GLSL："><a href="#GLSL：" class="headerlink" title="GLSL："></a><strong>GLSL：</strong></h3><p>基于OpenGL的OpenGL Shading Language</p>
<h3 id="CG："><a href="#CG：" class="headerlink" title="CG："></a><strong>CG：</strong></h3><p>由NVIDIA公司开发。Cg极力保留C语言的大部分语义</p>
<h3 id="HLSL-："><a href="#HLSL-：" class="headerlink" title="HLSL ："></a><strong>HLSL ：</strong></h3><p>基于DirectX的High Level Shading Language,</p>
</blockquote>
<hr>
<p>Unity官方手册上讲Shader程序嵌入的小片段是用Cg/HLSL编写的，从“<strong>CGPROGRAM”</strong>开始，到“<strong>CGEND”</strong>结束。</p>
<p>我们看一段由unity初始化的shader本体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   Shader <span class="string">"Custom/s1"</span> <span class="comment">//级联菜单/shader名称</span></div><div class="line">   &#123;</div><div class="line">Properties &#123;</div><div class="line">	_Color (<span class="string">"Color"</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">	_MainTex (<span class="string">"Albedo (RGB)"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125;<span class="comment">//主纹理</span></div><div class="line">	_Glossiness (<span class="string">"Smoothness"</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span><span class="comment">//光泽度</span></div><div class="line">	_Metallic (<span class="string">"Metallic"</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.0</span><span class="comment">//金属</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//属性  可在inspector中修改赋值  相当于供加工的材料</span></div><div class="line">SubShader &#123;</div><div class="line">	Tags &#123; <span class="string">"RenderType"</span>=<span class="string">"Opaque"</span> &#125;<span class="comment">//渲染标签</span></div><div class="line">	LOD <span class="number">200</span></div><div class="line"></div><div class="line">	CGPROGRAM</div><div class="line">	<span class="comment">// Physically based Standard lighting model, and enable shadows on all light types</span></div><div class="line">	<span class="comment">//基于物理的光照模型 打开所有光照类型的阴影</span></div><div class="line">	#pragma surface surf Standard fullforwardshadows</div><div class="line"></div><div class="line">	<span class="comment">// Use shader model 3.0 target, to get nicer looking lighting</span></div><div class="line">	<span class="comment">//使用3.0模型得到更好的视觉效果</span></div><div class="line">	#pragma target <span class="number">3.0</span></div><div class="line"></div><div class="line">	sampler2D _MainTex;</div><div class="line"></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></div><div class="line">		float2 uv_MainTex;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	half _Glossiness;</div><div class="line">	half _Metallic;</div><div class="line">	fixed4 _Color;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input IN, inout SurfaceOutputStandard o)</span> </span>&#123;</div><div class="line">		<span class="comment">// Albedo comes from a texture tinted by color</span></div><div class="line">		<span class="comment">//反照率来自于纹理着色的颜色</span></div><div class="line">		fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</div><div class="line">		o.Albedo = c.rgb;</div><div class="line">		<span class="comment">// Metallic and smoothness come from slider variables</span></div><div class="line">		<span class="comment">//金属性和平滑度来自于滑动变量</span></div><div class="line">		o.Metallic = _Metallic;</div><div class="line">		o.Smoothness = _Glossiness;</div><div class="line">		o.Alpha = c.a;</div><div class="line">	&#125;</div><div class="line">	ENDCG</div><div class="line">&#125;</div><div class="line">FallBack <span class="string">"Diffuse"</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="所以，"><a href="#所以，" class="headerlink" title="所以，"></a>所以，</h2><p>Unity官方主要是用Cg/HLSL编写Shader程序片段。Unity官方手册也说明对于Cg/HLSL程序进行扩展也可以使用GLSL，不过Unity官方建议使用原生的GLSL进行编写和测试。<br>如果不使用原生GLSL，你就需要知道你的平台必须是Mac OS X、OpenGL ES 2.0以上的移动设备或者是Linux。在一般情况下Unity会把Cg/HLSL交叉编译成优化过的GLSL。因此我们有多种选择，我们既可以考虑使用Cg/HLSL，也可以使用GLSL。<br>不过<strong>由于Cg/HLSL更好的跨平台性，更倾向于使用Cg/HLSL编写Shader程序。</strong></p>
<h2 id="第二节-固定管线"><a href="#第二节-固定管线" class="headerlink" title="第二节-固定管线"></a><strong>第二节-固定管线</strong></h2><p>我们采用更为简单易理解的方式去编写  那就是固定管线  在surface shader中pass通道被忽略  但是我们可以以一种更好的方式去理解</p>
<p>一个helloword性质的shader如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> Shader <span class="string">"Custom/s2"</span> &#123;</div><div class="line">SubShader&#123;</div><div class="line">   pass &#123;</div><div class="line"> color(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)<span class="comment">//白色</span></div><div class="line">        &#125;</div><div class="line">     &#125;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>把它和材质相结合之后  渲染出的球如下<br><img src="http://img.blog.csdn.net/20170126171134789?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW50YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="s21"></p>
<p> 但是我们看到他只是画出了一个球而已  没有任何三维特征<br> 我们再回到之前说的光照的阶段  如果一个三维物体想被看见  简单的来说要具备哪些必要的元素呢？<br> 那就是</p>
<h1 id="光"><a href="#光" class="headerlink" title="光"></a>光</h1><p>在固定管线中  其实有着简单的光照指令  这时候我们可以试着添加properties以供我们可以更好的添加需要加工的素材<br>像这样：<img src="http://img.blog.csdn.net/20170126183744537?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW50YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><strong>这样之后我们就可以在inspector里实时调节这个颜色</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">   Shader <span class="string">"test/s2"</span> &#123;</div><div class="line">properties</div><div class="line">&#123;</div><div class="line">	_color(<span class="string">"main color"</span>,color)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">&#125;</div><div class="line">SubShader&#123;</div><div class="line">pass &#123;</div><div class="line">	material<span class="comment">//命令块</span></div><div class="line">	&#123;</div><div class="line">         diffuse[_color]<span class="comment">//反射光</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line">	lighting on<span class="comment">// 打开光照的命令</span></div><div class="line">	<span class="comment">//color(1,1,1,1)</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<hr>
<blockquote>
<p>这下我们打开了光照  瞬间看起来像是那么回事了</p>
</blockquote>
<hr>
<p><img src="http://img.blog.csdn.net/20170126174056120?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW50YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="s22"></p>
<p>但是相比较而言似乎远远没有场景中其他物体特征那么明显<br>说到了光照自然不得不提光照模型：<br><img src="http://images2015.cnblogs.com/blog/746883/201603/746883-20160320162230318-945939529.png" alt="这里写图片描述"><br>那么我们把<strong>环境 反射 高光</strong>加入shader的固定管线之后再加入<strong>高光强度参数</strong>描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   Shader &quot;test/s2&quot; &#123;</div><div class="line">properties</div><div class="line">&#123;</div><div class="line">	_color(&quot;main color&quot;,color)=(1,1,1,1)//RGBA</div><div class="line">	_ambient(&quot;ambient&quot;,color)=(0.3,0.3,0.3,0.3)</div><div class="line">	_specular(&quot;specular&quot;,color)=(1,1,1,1)</div><div class="line">	_shininess(&quot;specular&quot;,range(0,8))=4</div><div class="line">&#125;</div><div class="line">SubShader&#123;</div><div class="line">pass &#123;</div><div class="line">	material</div><div class="line">	&#123;</div><div class="line">         diffuse[_color]//反射光</div><div class="line">         ambient[_ambient]//环境光</div><div class="line">         specular[_specular]//高光</div><div class="line">         shininess[_shininess]//高光强度</div><div class="line">	&#125;</div><div class="line">	lighting on// or off//打开光照</div><div class="line">	separatespecular on//镜面高光开启</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://img.blog.csdn.net/20170126180244050?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW50YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>到这里他已经比场景里其他东西真实度高得多了</p>
<p>#现在</p>
<p>下面我们开始加入 材质<br>我们用两张风格迥异的素材作为混合元素<br><img src="http://img.blog.csdn.net/20170126184714276?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW50YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20170126184729088?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW50YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>为了加入不同材质我们要加入一些其他亦可赛艇的东西<br>但这之前我们需要了解一点先导也就是<strong>alpha测试</strong><br>当渲染器在工作的时候必须要确定相对于摄像机的视角  物体的深度序列  来确定物体之间的遮挡  ，半透明物体的透光等  所以在<br>我们再来看看这张渲染步骤图：<br><img src="http://img.blog.csdn.net/20170126184239945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW50YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>通过以下叠加结合的过程当我们把alpha调低后就可以看到半透明的物体了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">   Shader &quot;test/s2&quot; &#123;</div><div class="line">properties</div><div class="line">&#123;</div><div class="line">	_color(&quot;main color&quot;,color)=(1,1,1,1)  //color RGBA</div><div class="line">	_ambient(&quot;ambient&quot;,color)=(0.3,0.3,0.3,0.3)</div><div class="line">	_specular(&quot;specular&quot;,color)=(1,1,1,1)</div><div class="line">	_shininess(&quot;specular&quot;,range(0,8))=4  //range（x,y）</div><div class="line">	_Emission(&quot;Emission&quot;,color)=(1,1,1,1)</div><div class="line">	_Maintex(&quot;MainTex&quot;,2d)=&quot;&quot;             //texture 2d</div><div class="line">	_SecondTex(&quot;SecondTex&quot;,2d)=&quot;&quot;</div><div class="line">&#125;</div><div class="line">SubShader&#123;</div><div class="line">Blend srcalpha OneminusSrcAlpha</div><div class="line">//混合1-scralpha前面的图中有提到</div><div class="line">pass &#123;</div><div class="line">     //______________________________________________________</div><div class="line">	material</div><div class="line">	&#123;</div><div class="line">         diffuse[_color]//反射光</div><div class="line">         ambient[_ambient]//环境光</div><div class="line">         specular[_specular]//高光</div><div class="line">         shininess[_shininess]//高光强度</div><div class="line">	&#125;</div><div class="line">	//________________________________________________________</div><div class="line">	lighting on// or off</div><div class="line">	separatespecular on//镜面高光</div><div class="line"></div><div class="line">	settexture[_Maintex]&#123;</div><div class="line">	    //主纹理</div><div class="line">		combine texture * primary double//结合，且将之前的x2 or quad x4</div><div class="line">		//primary 代表顶点光照（material命令快）过后的颜色</div><div class="line">	&#125;</div><div class="line">	settexture[_SecondTex]&#123;//第二纹理</div><div class="line">		combine texture * previous double//x2</div><div class="line">		//previous 代表所有之前的颜色</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20170204151458866?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW50YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>####　<strong>我们看到</strong> 　<br>者甚至出现了一个奇怪的好处就是可以营造</p>
<h3 id="镂空效果"><a href="#镂空效果" class="headerlink" title="镂空效果"></a><strong>镂空效果</strong></h3><p>Tiling表示UV坐标的缩放倍数，Offset表示UV坐标的起始位置。如下图可见<br><img src="http://images.cnitblog.com/blog/383191/201502/131811089648181.png" alt="这里写图片描述"><br><img src="http://images.cnitblog.com/blog/383191/201502/131811100429751.jpg" alt="这里写图片描述"><br>当我们贴上了三角面  则可以看到模型的与之对应的过程<br><img src="http://images.cnitblog.com/blog/383191/201502/131811113084266.png" alt="这里写图片描述"></p>
<hr>
<h3 id="一个模型能够正确被显示，贴图和模型的uv坐标必须能够对应"><a href="#一个模型能够正确被显示，贴图和模型的uv坐标必须能够对应" class="headerlink" title="一个模型能够正确被显示，贴图和模型的uv坐标必须能够对应"></a><strong>一个模型能够正确被显示，贴图和模型的uv坐标必须能够对应</strong></h3><p>而我们利用其起始坐标和缩放系数的修改就可以营造出<strong>运动和镂空</strong>等多种效果。</p>
<h2 id="第三节surface-shader"><a href="#第三节surface-shader" class="headerlink" title="第三节surface shader"></a><strong>第三节surface shader</strong></h2><p>我们再回到由unity初始化的surface shader中<br>当然我们学习surface最好的途径就是unity 手册的网站：<br><a href="https://docs.unity3d.com/Manual/SL-SurfaceShaders.html" target="_blank" rel="external">surface shader document</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">   Shader <span class="string">"Custom/s3"</span> &#123;</div><div class="line">Properties &#123;</div><div class="line">	_Color (<span class="string">"Color"</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">	_MainTex (<span class="string">"Albedo (RGB)"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125;</div><div class="line">	_Glossiness (<span class="string">"Smoothness"</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></div><div class="line">	_Metallic (<span class="string">"Metallic"</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line">SubShader &#123;</div><div class="line">	Tags &#123; <span class="string">"RenderType"</span>=<span class="string">"Opaque"</span> &#125;</div><div class="line">	<span class="comment">//渲染标签：渲染类型=不透明</span></div><div class="line">	LOD <span class="number">200</span></div><div class="line"></div><div class="line">	CGPROGRAM<span class="comment">//CG语言开始阶段</span></div><div class="line"></div><div class="line">	#pragma surface surf Standard fullforwardshadows</div><div class="line">	#pragma target <span class="number">3.0</span><span class="comment">//最高支持target5.0直接应用DX11</span></div><div class="line">	<span class="comment">//编译指令</span></div><div class="line">       <span class="comment">//#pragma surfaceFuntion Lightmodel [Optionalparams]</span></div><div class="line">	<span class="comment">//#pragma 函数名称 光照模式 [选项]</span></div><div class="line">	<span class="comment">//standard光照模型在unityPBSlighting.cginc中</span></div><div class="line">	<span class="comment">//默认fullforwardshadows 阴影</span></div><div class="line"></div><div class="line">	struct Input &#123;</div><div class="line">		float2 uv_MainTex;</div><div class="line">	&#125;;</div><div class="line">	<span class="comment">//纹理坐标必须以uv开头</span></div><div class="line">	sampler2D _MainTex;</div><div class="line">	half _Glossiness;</div><div class="line">	half _Metallic;</div><div class="line">	fixed4 _Color;</div><div class="line">	<span class="comment">//在CG语言中需对properties的变量再次声明一一对应</span></div><div class="line">	<span class="comment">//但是其变量类型并不是完全一致</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input IN, inout SurfaceOutputStandard o)</span> </span>&#123;</div><div class="line">		<span class="comment">// 来自纹理作色的反照率</span></div><div class="line">		fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</div><div class="line">		o.Albedo = c.rgb;</div><div class="line">		<span class="comment">// 一个能被滑块定制的决定平滑度和金属性的变量其实就是range那个能被滑条操纵的变量</span></div><div class="line">		o.Metallic = _Metallic;</div><div class="line">		o.Smoothness = _Glossiness;</div><div class="line">		o.Alpha = c.a;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//处理段</span></div><div class="line">	ENDCG<span class="comment">//CG语言结束阶段</span></div><div class="line">&#125;</div><div class="line">FallBack <span class="string">"Diffuse"</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>我们看到了几乎是完全两种语言一样  因为他就是两种语言  unity推崇的surface shader中应用了CG语言的一部分因此  在其中特定区域可以写CG语言  同时  surface shader本身就是对两种可编程管线也就是vertex shader和fragment shader的包装  也因此  其中可探究的部分  真可谓写一本书都不够</p>
<h3 id="下面"><a href="#下面" class="headerlink" title="下面"></a>下面</h3><p>我们就从上到下的顺序开始对其进行解析一个标准的surface sahder有哪些不同的地方</p>
<h4 id="1-渲染标签"><a href="#1-渲染标签" class="headerlink" title="1.渲染标签"></a>1.渲染标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">   Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</div><div class="line">//渲染标签：渲染类型=不透明</div></pre></td></tr></table></figure>
<p>？？？？？？？？？？？</p>
<h4 id="2-编译指令字段"><a href="#2-编译指令字段" class="headerlink" title="2.编译指令字段"></a>2.编译指令字段</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">      #pragma surface surf Standard fullforwardshadows</div><div class="line">#pragma target 3.0</div><div class="line">//编译指令</div><div class="line">      //#pragma surfaceFuntion Lightmodel [Optionalparams]</div><div class="line">//#pragma 函数名称 光照模式 [选项]</div><div class="line">//standard光照模型在unityPBSlighting.cginc中</div><div class="line">//默认fullforwardshadows 阴影</div></pre></td></tr></table></figure>
<p>由注释可以看到 函数名称后的<strong>光照模式和选项部分</strong>  其实是我们完全没有见过的东西</p>
<h1 id="Tips：PBS"><a href="#Tips：PBS" class="headerlink" title="Tips：PBS"></a>Tips：PBS</h1><p>（基于物理的光照运算，从unity5开始引入，技术源于迪士尼。在unity4中不可用）</p>
<hr>
<p><strong>2.1光照模式</strong></p>
<p> unity内部的东西实际上我们在客户端的安装目录中就可以找到这段指令的来源<br>Unity\Editor\Data\CGIncludes<br>这里包含了所有渲染需要用的引用<br>当我们找到了<strong>unityPBSlighting.cgnic</strong>这个文件就可以找到其来源</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">inline</span> half4 <span class="title">LightingStandard</span> <span class="params">(SurfaceOutputStandard s, half3 viewDir, UnityGI gi)</span></span></div><div class="line">   &#123;</div><div class="line">s.Normal = normalize(s.Normal);</div><div class="line"></div><div class="line">half oneMinusReflectivity;</div><div class="line">half3 specColor;</div><div class="line">s.Albedo = DiffuseAndSpecularFromMetallic (s.Albedo, s.Metallic, <span class="comment">/*out*/</span> specColor, <span class="comment">/*out*/</span> oneMinusReflectivity);</div><div class="line"></div><div class="line"><span class="comment">// shader relies on pre-multiply alpha-blend (_SrcBlend = One, _DstBlend = OneMinusSrcAlpha)</span></div><div class="line"><span class="comment">// this is necessary to handle transparency in physically correct way - only diffuse component gets affected by alpha</span></div><div class="line">half outputAlpha;</div><div class="line">s.Albedo = PreMultiplyAlpha (s.Albedo, s.Alpha, oneMinusReflectivity, <span class="comment">/*out*/</span> outputAlpha);</div><div class="line"></div><div class="line">half4 c = UNITY_BRDF_PBS (s.Albedo, specColor, oneMinusReflectivity, s.Smoothness, s.Normal, viewDir, gi.light, gi.indirect);</div><div class="line">c.rgb += UNITY_BRDF_GI (s.Albedo, specColor, oneMinusReflectivity, s.Smoothness, s.Normal, viewDir, s.Occlusion, gi);</div><div class="line">c.a = outputAlpha;</div><div class="line"><span class="keyword">return</span> c;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>尤其要注意的是  <strong>定义这类光照模式的时候要以lighting为开头</strong>否则编译会出错<br>这是unity5之后使用的新型光照模式<br>从这个文件中我们还可以找到其他的的模式类型也就是我们熟悉的BlinnPhong</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">inline fixed4 LightingBlinnPhong (SurfaceOutput s, half3 viewDir, UnityGI gi)</div><div class="line">&#123;</div><div class="line">	fixed4 c;</div><div class="line">	c = UnityBlinnPhongLight (s, viewDir, gi.light);</div><div class="line"></div><div class="line">	#if defined(DIRLIGHTMAP_SEPARATE)</div><div class="line">		#ifdef LIGHTMAP_ON</div><div class="line">			c += UnityBlinnPhongLight (s, viewDir, gi.light2);</div><div class="line">		#endif</div><div class="line">		#ifdef DYNAMICLIGHTMAP_ON</div><div class="line">			c += UnityBlinnPhongLight (s, viewDir, gi.light3);</div><div class="line">		#endif</div><div class="line">	#endif</div><div class="line"></div><div class="line">	#ifdef UNITY_LIGHT_FUNCTION_APPLY_INDIRECT</div><div class="line">		c.rgb += s.Albedo * gi.indirect.diffuse;</div><div class="line">	#endif</div><div class="line"></div><div class="line">	return c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2.2选项部分</strong><br>Optional parameters在unity手册中写的比较清楚  类型过于多也不适合去展开说明我们就挑选出现了的阴影选项去讲解一下</p>
<p>###Shadows and Tessellation - .附加指令以控制如何处理阴影和曲面细分。</p>
<p><strong>addshadow</strong> - 通常使用自定义顶点修改，使得阴影投射也获得任何过程顶点动画。</p>
<p><strong>fullforwardshadows</strong> - 支持正向渲染路径中的所有光影类型。默认情况下，着色器仅支持来自正向渲染中的一个定向光源的阴影（以保存内部着色器变量计数）。如果需要在正向渲染中点或点亮阴影，请使用此指令。</p>
<p><strong>tessellate:TessFunction</strong> - 使用dx11计算曲面细分因子</p>
<h3 id="3-定义部分"><a href="#3-定义部分" class="headerlink" title="3.定义部分"></a><strong>3.定义部分</strong></h3><p>这部分倒是没什么说的  CG语言入门不是本篇文章的目的，所以各种变量类型以及作用都不做介绍<br>到了这里本文其实是更重视流程的阐述  所以在这个思想上我们往下看<br>不能直接处理定义在properties 中的元素<br>所以要在处理之前做定义以映射相关元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">struct Input &#123;</div><div class="line">	float2 uv_MainTex;</div><div class="line">&#125;;</div><div class="line">//纹理坐标必须以uv开头</div><div class="line">sampler2D _MainTex;</div><div class="line">half _Glossiness;</div><div class="line">half _Metallic;</div><div class="line">fixed4 _Color;</div><div class="line">//在CG语言中需对properties的变量再次声明一一对应</div><div class="line">//但是其变量类型并不是完全一致</div></pre></td></tr></table></figure></p>
<h3 id="4-函数部分"><a href="#4-函数部分" class="headerlink" title="4.函数部分"></a><strong>4.函数部分</strong></h3><p>所定义的函数部分要从更高的层面去讲解了<br>必须要回到我们的引用中去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">  void surf (Input IN, inout SurfaceOutputStandard o) &#123;</div><div class="line">	// 来自纹理作色的反照率</div><div class="line">	fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</div><div class="line">	o.Albedo = c.rgb;</div><div class="line">	// 一个能被滑块定制的决定平滑度和金属性的变量其实就是range那个能被滑条操纵的变量</div><div class="line">	o.Metallic = _Metallic;</div><div class="line">	o.Smoothness = _Glossiness;</div><div class="line">	o.Alpha = c.a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参数列表，Cg 中还提供了三个关键字，in、out、inout，用于表示函数的输入参数的传递方式，称为输入/输出关键字，这组关键字可以和语义词合用表达硬件上不同的存储位置，即同一个语义词，使用in 关键字修辞和out 关键词修辞，表示的图形硬件上不同的寄存器。<br>我们在之前的pbslighting文件中找到参数列表中的输入输出参数类型是什么<br>输入部分（初始化中定义过了）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      struct Input &#123;</div><div class="line">	float2 uv_MainTex;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>输出部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">   struct SurfaceOutputStandard</div><div class="line">   &#123;</div><div class="line">fixed3 Albedo;		// base (diffuse or specular) color</div><div class="line">fixed3 Normal;		// tangent space normal, if written</div><div class="line">half3 Emission;</div><div class="line">half Metallic;		// 0=non-metal, 1=metal</div><div class="line">// Smoothness is the user facing name, it should be perceptual smoothness but user should not have to deal with it.</div><div class="line">// Everywhere in the code you meet smoothness it is perceptual smoothness</div><div class="line">half Smoothness;	// 0=rough, 1=smooth</div><div class="line">half Occlusion;		// occlusion (default 1)</div><div class="line">fixed Alpha;		// alpha for transparencies</div><div class="line">   &#125;;</div></pre></td></tr></table></figure></p>
<p>整体来看  我们也能熟悉这个整体的套路<br>函数作为输入和输出的载体，而输入和输出都有着固定的模式，根据输入的IN计算OUT进入缓存。</p>
<p>当我们完成了surface shader的编写可以通过查看shader编译结果的方式了解整个处理流程<br>短短的一段surface shader被编译成8000多行的真正的执行shader其中还有d3d的支持部分<br>我们截取一小段来看一下例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"> -- Vertex shader for &quot;d3d11&quot;:</div><div class="line"> // Stats: 22 math</div><div class="line"> Uses vertex data channel &quot;Vertex&quot;</div><div class="line"> Uses vertex data channel &quot;Color&quot;</div><div class="line"> Uses vertex data channel &quot;TexCoord&quot;</div><div class="line"></div><div class="line"> Constant Buffer &quot;$Globals&quot; (128 bytes) on slot 0 &#123;</div><div class="line"> Vector4 _MainTex_ST at 96</div><div class="line">  &#125;</div><div class="line"> Constant Buffer &quot;UnityLighting&quot; (720 bytes) on slot 1 &#123;</div><div class="line">   Vector4 unity_SHBr at 656</div><div class="line">   Vector4 unity_SHBg at 672</div><div class="line">   Vector4 unity_SHBb at 688</div><div class="line">   Vector4 unity_SHC at 704</div><div class="line"> &#125;</div><div class="line">Constant Buffer &quot;UnityPerDraw&quot; (352 bytes) on slot 2 &#123;</div><div class="line">  Matrix4x4 glstate_matrix_mvp at 0</div><div class="line">  Matrix4x4 unity_ObjectToWorld at 192</div><div class="line">  Matrix4x4 unity_WorldToObject at 256</div><div class="line"> &#125;</div><div class="line"></div><div class="line">-- Fragment shader for &quot;d3d11&quot;:</div><div class="line"> // Stats: 30 math, 4 textures, 2 branches</div><div class="line"> Set 2D Texture &quot;_MainTex&quot; to slot 0</div><div class="line"> Set 3D Texture &quot;unity_ProbeVolumeSH&quot; to slot 1</div><div class="line"></div><div class="line"> Constant Buffer &quot;$Globals&quot; (128 bytes) on slot 0 &#123;</div><div class="line">  Float _Glossiness at 64</div><div class="line">  Float _Metallic at 68</div><div class="line">  Vector4 _Color at 80</div><div class="line"> &#125;</div><div class="line"> Constant Buffer &quot;UnityLighting&quot; (720 bytes) on slot 1 &#123;</div><div class="line">   Vector4 unity_SHAr at 608</div><div class="line">   Vector4 unity_SHAg at 624</div><div class="line">   Vector4 unity_SHAb at 640</div><div class="line"> &#125;</div><div class="line"> Constant Buffer &quot;UnityProbeVolume&quot; (112 bytes) on slot 2 &#123;</div><div class="line">  Matrix4x4 unity_ProbeVolumeWorldToObject at 16</div><div class="line">  Vector4 unity_ProbeVolumeParams at 0</div><div class="line">Vector3 unity_ProbeVolumeSizeInv at 80</div><div class="line">  Vector3 unity_ProbeVolumeMin at 96</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这两个片段很好的描述了整个着色过程体现在代码阶段的样貌</p>
<h1 id="当然"><a href="#当然" class="headerlink" title="当然"></a>当然</h1><p>这只是凤毛菱角  函数中对于信息的计算和各种算法以及处理流程才是最重要的。而CG的入门应该在<br><a href="http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter01.html" target="_blank" rel="external">NVIDIA_CG_page</a>这里去入门。我们主要说流程以及不同的地方。</p>
<p>下一篇文章我们会讲解unity shader编写中怎样实现一些好的效果</p>
<h1 id="Good-bye-Next-Month"><a href="#Good-bye-Next-Month" class="headerlink" title="Good bye Next Month~~"></a>Good bye Next Month~~</h1>

<!-- Tags -->



<div class="tags">
    <a href="/tags/CG-shader/" class="button small">CG-shader</a>
</div>



<!-- Comments -->
<div>
    
    <hr />
    <h3>留言:</h3>
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>



</div>



            </div>
        </div>

        <!-- Footer -->
<footer id="footer">
    <div class="inner">
        <section>
            <h2>About</h2>
            <div>
                Winshare.tech
            </div>
        </section>
        <section>
            <h2>Follow</h2>
            <ul class="icons">
                
                    <li><a href="https://twitter.com/?lang=en" class="icon style2 fa-twitter" target="_blank" ><span class="label">Twitter</span></a></li>
                
                
                    <li><a href="https://www.facebook.com/winshare.tom/" class="icon style2 fa-facebook" target="_blank" ><span class="label">Facebook</span></a></li>
                
                
                    <li><a href="https://www.instagram.com/" class="icon style2 fa-instagram" target="_blank" ><span class="label">Instagram</span></a></li>
                
                
                    <li><a href="https://dribbble.com/" class="icon style2 fa-dribbble" target="_blank" ><span class="label">Dribbble</span></a></li>
                
                
                    <li><a href="https://github.com/OOXXXXOO/" class="icon style2 fa-github" target="_blank" ><span class="label">GitHub</span></a></li>
                
                
                    <li><a href="https://plus.google.com/" class="icon style2 fa-google-plus" target="_blank" ><span class="label">Google+</span></a></li>
                
                
                    <li><a href="https://www.behance.net/" class="icon style2 fa-behance" target="_blank" ><span class="label">Behance</span></a></li>
                
                
                    <li><a href="https://500px.com/" class="icon style2 fa-500px" target="_blank" ><span class="label">500px</span></a></li>
                
                
                    <li><a href="tanwenxuan@live.com/" class="icon style2 fa-envelope-o" target="_blank" ><span class="label">Email</span></a></li>
                
                
                    <li><a href="\#" class="icon style2 fa-rss" target="_blank" ><span class="label">RSS</span></a></li>
                
            </ul>
        </section>
        <ul class="copyright">
            <li>&copy; Untitled. All rights reserved</li>
            <li>Design: <a href="http://html5up.net" target="_blank">HTML5 UP</a></li>
            <li>Hexo: <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></li>
        </ul>
    </div>
</footer>
    </div>

    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- skel -->
<script src="/js/skel.min.js"></script>

<!-- Custom Code -->
<script src="/js/util.js"></script>

<!--[if lte IE 8]>
<script src="/js/ie/respond.min.js"></script>
<![endif]-->

<!-- Custom Code -->
<script src="/js/main.js"></script>

<!-- Gallery -->
<script src="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->

<script type="text/javascript">
    var disqus_shortname = 'klugjo';

    (function(){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>


</body>

</html>